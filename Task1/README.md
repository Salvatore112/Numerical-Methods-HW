**Описание вычислительной машины**

- Processor	12th Gen Intel(R) Core(TM) i7-12700H   2.30 GHz
- Installed RAM	16.0 GB (15.7 GB usable)
- System type	64-bit operating system, x64-based processor
  
**Описание используемого ПО**

- Операционная система Windows 11 Home (21H2)
- OpenMP 4.5
- gcc 13.2.1 

**Оценка эффективности параллельной версии алгоритма**

Рассмотрим следующие функции:
$u_1 = x^2 + y$, $u_2 = sqrt{(x^2+y^2)}$, $u_3 = e^x + e^y$

Эксперементы будут проходить с eps = 0.01 и размером блока 64 на 1-ом и 8-ми потоках
  
<details>
<summary>Результаты эксперемента для $u_1$ </summary>
  
![u1](https://github.com/Salvatore112/Numerical-Methods-HW/assets/113641510/1e158580-d418-42f0-9983-a2dd1cc51b9b)

</details>

<details>
<summary>Результаты эксперемента для $u_2$ </summary>
  
![u2](https://github.com/Salvatore112/Numerical-Methods-HW/assets/113641510/d5b96c29-f7f0-4e4e-ab55-6a959af1ebf6)

</details>
<details>
<summary>Результаты эксперемента для $u_3$ </summary>
  
![u3](https://github.com/Salvatore112/Numerical-Methods-HW/assets/113641510/8ad2e7cd-4350-48a1-9912-e5ea1e73b358)
</details>

Исходя из данных результатов, можно заметить, что на меньших размерах сетки ускорения не происходит из-за того что размеры блока очень большие по сравнению с размерами сетки, что не позволяет эффективно распараллелить вычисления между потоками. Кроме того, общие причины, которые могут повлиять на ускорение распараллеливания для всех этих трех функций могут быть следующие:
- Эти функции включают относительно простые математические операции, которые могут не полностью использовать вычислительные ресурсы, доступные в средах параллельного выполнения
- Все три функции имеют зависимости данных или последовательные вычисления, которые ограничивают возможный уровень параллелизма. Например, в $sqrt(x^2+y^2)$ каждое вычисление зависит от результата операции извлечения квадратного корня, что ограничивает параллельное выполнение

Давайте теперь рассмотрим следующую функцию:
$u_4$ = sin(100*x) * cos(100*y)

<details>
<summary>Результаты эксперемента для $u_4$ с теми же условиями </summary>
  
![u4](https://github.com/Salvatore112/Numerical-Methods-HW/assets/113641510/ac0cfe53-13e1-4092-825e-1664c39a520f)

</details>

Можно наблюдать то, что ускорение в данном случае намного выше, что может быть связано с самой функцией $u_4$, содержащей синус и косинус с высокой частотой, вычисление значений которых может потребовать множество арифметических операций, что может быть эффективно распаралелено.

